\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}

\section{integration}
All things considered this part of the lab wasn't too hard. Most of it was copying code from the lab 7. The integration c code is almost identical to the one I wrote last week. The only difference is that the integrand, lower bound, and upper bound variables were replaced with a struct variable. In this context the struct acts as a super variable, containing a set of smaller variables within it. Since my integration functions now accept a struct I also had to extract the relevant variables from the struct so my code could use them. Other than these changes my integration.c file is exactly the same as earlier. This also means the complexity of each function is the same. As such the midpoint, and both Simpson's functions still have constant run time with O(1). Similarly the Gaussian quadrature is still O(n), indicating a linear run time. The only loop in this function is in the Gauss quad and the loop constants are still the same. The reset integration bounds, c and m, were constant throughout the loop. Additionally,while the values of t and w did change for each iteration, their values were onlyread from an array, rather than written. 

Of more interest in this part of the lab are the integration header. This simply defines the integration functions and struct so the integration function can be compiled. Similarly the Makefile is just a fancy compile command. The Makefile does account for which functions have changed and doesn't waste time compiling functions that are the same. It also compiles many programs at a time, dramatically reducing how much I have to type into the command line. The Makefile can also remove the created object file using \textit{make clean}. There are no loops in either the header nor the Makefile. Additionally, if the header and Makefile have time complexities, they would be constant: O(1).

\section{csv}
This part of the code was significantly more difficult. I started by writing the Makefile for these functions. This was more complicated. Where all of the files were in the same directory for the integration library, the functions, headers, and output destination were different for the csv library. To properly reference the necessary files I had to add the folder location of the functions and header to the Makefile. A few flags were also required to explain to the computer what to do. The file was created in the proper directory by simply specifying the directory it should be created in. I also added a clean function so the object files could be removed as desired. When it was finished I added a few lines to the Makefile to both compile and remove my csv reading code as desired. Again, if a Makefile has a time complexity it would by O(1). The Makefile has no loops.

The csv reading code was largely built on code written by other people. I used Professor Rozier's input validation code to check the inputs of the csv file. I used code taken from the functions in the tools directory to read the csv itself. I also used some of my old code to allocate memory space for a matrix. I attempted to modify the cb1 function so that it would read and store data from the csv file into the matrix. I then used another portion of my code to print the matrix to the screen. This is an extremely Frankenstein like code, so its functionality is in question. I certainly have a reduced understanding of the program since I did not personally write most of it. Nevertheless there are only three loops in the code. The first loop allocates space to the matrix, the relevant constant here is a variable describing the number of columns and one describing the number of rows in the csv file. The second loop stores the values from the csv file into the matrix. The loop invariants are the two variables that describe the rows and columns of the matrix and csv file. The final loop prints the matrix to the screen. Constants here are the variables describing the rows and columns of the matrix. Since the loops have to run twice, in order to account for the rows and columns of the matrix this code has a complexity of O($n^2$), indicating quadratic run time.

\end{document}
